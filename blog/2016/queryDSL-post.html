<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Construye tu propia DSL</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Construye tu propia DSL">
    <meta name="author" content="pvidasoftware">
    <meta name="keywords" content="blog,asciidoc">
    <meta name="generator" content="JBake">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@pvidasoftware">
    <meta name="twitter:creator" content="@pvidasoftware">
    <meta name="twitter:title" content="Construye tu propia DSL">
    <meta name="twitter:description" content="Construye tu propia DSL">
    <meta name="twitter:image" content="https://pvidasoftware.github.io/blog/slides/pvlogo.png">


    <!-- Le styles -->
    <link href="http://netdna.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.css" rel="stylesheet">
    <link href="../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../../css/asciidoctor.css" rel="stylesheet" type="text/css">
    <link href="../../css/base.css" rel="stylesheet" type="text/css">
    <link href="../../css/prettify.css" rel="stylesheet" type="text/css">



    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="../../favicon.ico">
  </head>

  <body onload="prettyPrint()">


	
		<!-- Fixed navbar -->
    <nav class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../">@pvidasoftware</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="../../index.html">Home</a></li>
            <li><a href="../../about.html">About</a></li>
            <li><a href="../../feed.xml">Subscribe</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Slides <b class="caret"></b></a>
              <ul class="dropdown-menu">
	
		    <li><a href="../../slides/2016/ddr/docu-driven-rest.html">Testea y Documenta tu REST</a></li>
  	
		    <li><a href="../../slides/puravida-software.html">Quién es Puravida Software</a></li>
  	
              </ul>
            </li>
          </ul>

          

          <ul class="nav navbar-nav navbar-right share-buttons">
            
            <li><a href="https://twitter.com/intent/tweet?source=https%3A%2F%2Fpvidasoftware.github.io/blog/blog/2016/queryDSL-post.html&text=Construye tu propia DSL%20https%3A%2F%2Fpvidasoftware.github.io/blog/blog/2016/queryDSL-post.html&via=pvidasoftware" target="_blank" title="Tweet"><i class="fa fa-twitter-square fa-2x"></i></a></li>

            
            <li><a href="https://plus.google.com/share?url=https%3A%2F%2Fpvidasoftware.github.io/blog/blog/2016/queryDSL-post.html" target="_blank" title="Construye tu propia DSL"><i class="fa fa-google-plus-square fa-2x"></i></a></li>

            <li><a href="http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fpvidasoftware.github.io/blog/blog/2016/queryDSL-post.html&title=Construye tu propia DSL&summary=&source=https%3A%2F%2Fpvidasoftware.github.io/blog/blog/2016/queryDSL-post.html" target="_blank" title="Share on LinkedIn"><i class="fa fa-linkedin-square fa-2x"></i></a></li>
            <li><a href="mailto:?subject=PuraVidaSoftware&body=:%20https%3A%2F%2Fpvidasoftware.github.io%2Fblog" target="_blank" title="Email"><i class="fa fa-envelope-square fa-2x"></i></a></li>
          </ul>

        </div><!--/.nav-collapse -->
      </div>
    </nav>


	<div class="container">

	<div class="page-header">
		<h1>Construye tu propia DSL</h1>
	    <p><em>11 febrero 2016</em></p>
	</div>

	<p><div class="sect1">
<h2 id="dsl_con_groovy">DSL con Groovy</h2>
<div class="sectionbody">
<div class="paragraph">
<p>DSL, o <a href="https://es.wikipedia.org/wiki/Lenguaje_espec%C3%ADfico_del_dominio">Lenguaje específico de dominio</a>, con Groovy
es realmente "sencillo" una vez que se entiende. Existen numerosos recursos, e incluso libros dedicados a ello exclusivamente,
por lo que no nos extenderemos demasiado en este post, simplemente apuntar que puedes diseñar tu propio DSL de tal forma
que la comunicación entre departamentos, por ejemplo, sea mucho más fluida y clara, o que tu código sea mucho más fácil de entender.</p>
</div>
<div class="paragraph">
<p>Para ello vamos a desarrollar un pequeño DSL que nos permitirá construir sentencias SQL (de toda la vida) de una forma
más manejable.</p>
</div>
<div class="sect2">
<h3 id="querydsl">QueryDSL</h3>
<div class="paragraph">
<p>( Recuerda que puedes obtener el código de <a href="https://github.com/pvidasoftware/QueryDSL">https://github.com/pvidasoftware/QueryDSL</a> )</p>
</div>
<div class="paragraph">
<p>Mediante QueryDSL pretendemos obtener una String para poder lanzar consultas a nuestro motor de base de datos.
De forma tradicional haríamos algo parecido a:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">String query = "select a.field1, a.field2 from mytable a inner join table2 b on a.field1 = b.field1 where a.field = 501 group by 1";</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como puedes imaginar, cuando la lista de campos crece, el número de joins aumenta o las condiciones varían la lógica para
construir la cadena se incrementa haciendola muchas veces imposible de seguir/entender.</p>
</div>
<div class="paragraph">
<p>Hoy en día exisen numerosos frameworks que ocultan esta complejidad y que incluso hacen el mapping de los datos a objetos, pero
hay también muchas veces donde no podemos/queremos disponer de estos frameworks.</p>
</div>
<div class="paragraph">
<p>Imaginemos el ejemplo anterior escrito de esta forma:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>def queryDSL = QueryDSL.build {
        select 'a.field1, a.field2'  <b class="conum">(1)</b>
        from 'mytable a'             <b class="conum">(2)</b>
        where{                       <b class="conum">(3)</b>
            and{
                eq "a.field1", 501
            }
        }
        innerJoin "table2 b" on "a.field1" eq "b.field1"  <b class="conum">(4)</b>
        groupBy 1   <b class="conum">(5)</b>
    }
String select = queryDSL.SQL</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>campos que queremos</p>
</li>
<li>
<p>de qué tabla</p>
</li>
<li>
<p>condiciones de filtro</p>
</li>
<li>
<p>unión con otras tablas</p>
</li>
<li>
<p>agrupar por el primer campo</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Como vemos, las diferentes partes de la sentencia se encuentran separadas de tal forma que nos permite comentarios:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def queryDSL = QueryDSL.build {
        // tomamos dos campos e ignoramos el resto
        select 'a.field1, a.field2'
....</code></pre>
</div>
</div>
<div class="paragraph">
<p>o incluso que el orden de la sintáxis no sea rígido :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def queryDSL = QueryDSL.build {
        select 'a.field1, a.field2'
        from 'mytable a'
        innerJoin "table2 b" on "a.field1" eq "b.field1"
        where{
....</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="construyendo_nuestra_querydsl">Construyendo nuestra QueryDSL</h3>
<div class="paragraph">
<p>La idea de QueryDSQL es que mediante una closure le iremos indicando las diferentes partes de una query para que al final
nos devuelva una cadena especialmente diseñada para ser ejecutada como sentencia SQL.
Así vemos que nuestra DSL tendría que tener una forma de especificar:
 - campo(s) a recuperar
 - tabla a la que consultar
 - posibilidad de enlazar con otras tablas (join)
 - sintáxis (opcinal) para poder filtrar (where) con posibilidad de parámetros con nombres
 - sintáxis (opcional) para poder agrupar</p>
</div>
<div class="paragraph">
<p>Además vamos a querer que esta DSL nos permita obtener la query para hacer una select y/o un count sin tener que volver
 a escribir la closure.</p>
</div>
</div>
<div class="sect2">
<h3 id="factoría_querydsl">Factoría QueryDSL</h3>
<div class="paragraph">
<p>Lo primero que crearemos será un método estático que aceptará una "closure" como argumento (para saber más de closures
en groovy visita la documentación de <a href="http://groovy-lang.org/closures.html:">Groovy Lang</a> ):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def static QueryDSL build( closure ) {
        QueryDSL dsl = new QueryDSL()
        closure.delegate = dsl
        closure()
        dsl
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como puedes ver el método build crea una clase del tipo QueryDSL que al ser privada sólo puede ser creada por él, y se
lo asigna a la closure como delegate. De esta forma cuando se ejecute la closure los métodos que se llamen dentro de ella
que no tenga serán redirigidos al delegate para que los resuelva.</p>
</div>
</div>
<div class="sect2">
<h3 id="populando_el_dsl">"Populando" el dsl</h3>
<div class="paragraph">
<p>La closure irá llamando a métodos en nuestro <strong>dsl</strong> delegate pasandole argumentos.
De esta forma si la closure llama a un método "select" y el delegate lo implementa, este será llamado automáticamente.
Además gracias a Groovy elegirá el método más adecuado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">   def select(String field){
        this.fields = field
    }

    def select(String[]fields){
        this.fields = fields.join(',')
    }

    def select(List fields){
        this.fields = fields.join(',')
    }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="usando_el_dsl">Usando el dsl</h3>
<div class="paragraph">
<p>Una vez que tenemos un queryDSL "populado" podremos solicitarle que nos devuelva por ejemplo la sentencia SQL para ser
usada en un data source o la sentencia SQL para contar el número de registros que cumplen la condición:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">new Sql(dataSource).rows(queryDSL.SQL)
new Sql(dataSource).rows(queryDSL.CountSQL)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="construyendo_la_sentencia">Construyendo la sentencia</h3>
<div class="paragraph">
<p>Cuando le pedimos la cadena SQL a nuestro dsl, este simplemente irá construyendo la sentencia con los datos que ha ido
guardando durante la ejecución de la closure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy"> public String getSQL( ){
        StringWriter writer = new StringWriter()
        writer.write("SELECT $fields")
        writer.write("\nFROM \n$fromTables")
        if( whereStr &amp;&amp; whereStr.length())
            writer.write("\n$whereStr")
        if( groupStr &amp;&amp; groupStr.length())
            writer.write("\nGROUP BY $groupStr")
        if( trace ){
            println( writer.toString() )
        }
        writer.toString()
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este DSL es muy básico y no realiza todas las comprobaciones que se deberían pero la idea se entiende. Simplemente va
uniendo las diferentes partes que ha ido guardando. De esta forma el mismo objeto nos puede devolver un SELECT que un
COUNT</p>
</div>
</div>
<div class="sect2">
<h3 id="rizando_el_rizo">Rizando el rizo</h3>
<div class="paragraph">
<p>Hasta aquí el DSL no tiene mucha complicación y aunque ya nos puede servir para hacer cosas sencillas en muchos casos
nuestro lenguaje de negocio nos pedirá que seamos un poco más "rico" en la composición.</p>
</div>
<div class="paragraph">
<p>Un buen ejemplo en QueryDSL es la parte en la que queremos indicar la unión con otra table e indicar los campos por
 los que queremos realizar esta union:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def queryDSL = QueryDSL.build {
....
        innerJoin "table2 b" on "a.field1" eq "b.field1"
....
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nuestro lenguaje va a permitirnos indicar la tabla mediante <strong>innerJoin</strong> y además para este caso nos va a permitir especificar
por qué campos hacerlo mediante <strong>on</strong> y cómo realizar esta unión mediante alguno de los operadores <strong>eq,ne,le,gt,&#8230;&#8203;</strong>
 He buscado que esta sintáxis sea similar a la típica de una sentencia SQL para facilitar su uso, pero con un poco de imaginación
 podríamos haber diseñado otro DSL que nos resulte más explicativo, como por ejemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def queryDSL = QueryDSL.build {
....
        // una innerJoin un poco más verbose:
        la unes con "table2" por el campo "field1" cuando son iguales
....
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para poder hacer que nuestra DSL acepte la sintáxis expuesta usaremos una técnica de Groovy donde el método <strong>innerJoin</strong>
devuelve un mapa de closures admitidas (en nuestro caso <strong>on</strong> únicamente). Esta técnica se puede usar recursivamente de
tal forma que una closure nos devuelva un nuevo mapa con la sintáxis que admite después de ella:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def innerJoin( String table  ){
        join("inner",table)
}

def join( String op, String table2){
        QueryDSL dsl = this
        [
                on:{ f1 -&gt;
                    [
                     eq:{f2-&gt;
                        dsl.addJoin(op,table2,f1,'=',f2)
                         dsl
                     },
                     ge:{f2-&gt;
                         dsl.addJoin(op,table2,f1,'&gt;=',f2)
                         dsl
                     },
                     le:{f2-&gt;
                         dsl.addJoin(op,table2,f1,'=&lt;',f2)
                         dsl
                     },
                     gt:{f2-&gt;
                         dsl.addJoin(op,table2,f1,'&gt;',f2)
                         dsl
                     },
                     lt:{f2-&gt;
                         dsl.addJoin(op,table2,f1,'&lt;',f2)
                         dsl
                     },
                     distinct:{f2-&gt;
                         dsl.addJoin(op,table2,f1,'&lt;&gt;',f2)
                         dsl
                     },
                    ]
                }
        ]
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como podemos ver <strong>innerJoin</strong> simplemente delega en el método <strong>join</strong> indicándole el tipo join que queremos hacer (inner, left, right&#8230;&#8203;)
 y pasándole el argumento que ha recibido (String table).</p>
</div>
<div class="paragraph">
<p>Lo primero que hará <strong>join</strong> será guardarse una referencia a sí mismo para poder continuar con la closure principal una vez
interpretada en la que estamos y después devolverá un Map de closures donde la clave permitirá a Groovy saber cúal ejecutar, <strong>on</strong>
en nuestro caso.</p>
</div>
<div class="paragraph">
<p><strong>on</strong> aceptará como argumentos el nombre de un campo (f1) y a su vez devolverá un nuevo mapa de las posibles closures que
admite ( eq, ge, le, .. ). En este caso cada una de ellas espera una cadena que indica el segundo campo (f2) y como todas
son muy parecidas simplemente llamamos a una función común <strong>addJoin</strong> donde unimos todos los argumentos que hemos ido recolectando.</p>
</div>
<div class="paragraph">
<p>Por último las closures finales de <strong>innerJoin</strong> devolverán la referencia que guardamos al inicio para que se siga con nuestro DSL.</p>
</div>
</div>
<div class="sect2">
<h3 id="bien_y_para_qué_una_dsl">Bien, &#8230;&#8203; y para qué una DSL ?</h3>
<div class="paragraph">
<p>Crear tus propias DSLs te puede permitir facilitar la interacción con la parte de negocio (la gente de ventas, contabilidad, &#8230;&#8203;).
Por ejemplo, supongamos que has diseñado un sistema de seguimiento de entregas para el departamento de atención al cliente donde existe
un compromiso de entrega en función del dia de la semana, del año, si es fiesta, etc.</p>
</div>
<div class="paragraph">
<p>Podríamos diseñar un DSL que el departamento de atencion al cliente podría proporcionarnos cada mes parecido a:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>pedido Lunes, Miercoles, Viernes     entrega  2 días despues
pedido Martes                        entrega  Miercoles
pedido 6 de Enero                    entrega  9 enero</code></pre>
</div>
</div>
<div class="paragraph">
<p>la imaginación es el límite.</p>
</div>
</div>
</div>
</div></p>

	</div>


    <footer class="footer">
      <div class="container">
        <p class="text-muted">PuraVida Software,SL c/ Betancunia 1, local A, Madrid 28017, <a href="mailto:contacto@puravida-software.com">Contacto</a>
            <span class="credit">&copy; 2016 | Mixed with <a href="http://getbootstrap.com/">Bootstrap v3.1.1</a> | Baked with <a href="http://jbake.org">JBake v2.4.0</a></span>
        </p>
      </div>
    </footer>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../../js/jquery-1.11.1.min.js"></script>
    <script src="../../js/bootstrap.min.js"></script>
    <script src="../../js/prettify.js"></script>

    

  </body>

<!-- google -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-687332-8', 'auto');
  ga('send', 'pageview');

</script>

<!-- twitter -->
  <script>window.twttr = (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0],
      t = window.twttr || {};
    if (d.getElementById(id)) return t;
    js = d.createElement(s);
    js.id = id;
    js.src = "https://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js, fjs);

    t._e = [];
    t.ready = function(f) {
      t._e.push(f);
    };

    return t;
  }(document, "script", "twitter-wjs"));</script>
<!-- twitter -->

</html>