<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JBake</title>
    <link>https://pvidasoftware.github.io/blog</link>
    <atom:link href="https://pvidasoftware.github.io/blog/feed.xml" rel="self" type="application/rss+xml" />
    <description>JBake Bootstrap Template</description>
    <language>en-gb</language>
    <pubDate>vie, 19 feb 2016 11:41:42 +0100</pubDate>
    <lastBuildDate>vie, 19 feb 2016 11:41:42 +0100</lastBuildDate>

    
    <item>
      <title>Test Driven para documentar RESTful (1/2)</title>
      <link>https://pvidasoftware.github.io/blog/blog/2016/twitterpeople_1_2.html</link>
      <pubDate>vie, 19 feb 2016 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">blog/2016/twitterpeople_1_2.html</guid>
      <description>
      &lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;usar_los_test_para_documentar_tus_servicios_restful&quot;&gt;Usar los test para documentar tus servicios RESTful&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;En esta serie de post vamos a ver cómo aprovechar tus pruebas contra un servicio REST (¿porque haces test
  en tus desarrollos, verdad ?) para que automáticamente generen una documentación sobre el mismo que pueda servir al
  resto del equipo a comprender el API. Al ser los propios test los que generarán la documentación tendremos la seguridad
  que esta se encontrará actualizada pues si falla un test ni se genera producto ni se genera documentación.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Existen herramientas orientadas a la documentación de servicios REST como &lt;a href=&quot;http://swagger.io/&quot;&gt;Swagger&lt;/a&gt;,
&lt;a href=&quot;http://jsondoc.org/&quot;&gt;JSONDoc&lt;/a&gt; e incluso muchas de ellas incorporan un &quot;playground&quot; donde podemos interactuar contra el servicio.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Sin embargo Swagger puede ser una utilidad muy densa y si el proyecto es pequeño-mediano no justificar su uso. Así mismo
JSONDoc no se integra correctamente con un controller Grails (o no he sido capaz de hacerlo).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;spring_rest_doc&quot;&gt;Spring-rest-doc&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/spring-projects/spring-restdocs/&quot;&gt;Spring-rest-doc&lt;/a&gt; es un proyecto de Spring con un enfoque algo
diferente a las herramientas comentadas donde la idea principal es unir una documentación propia del proyecto junto con
 los resultados de las pruebas unitarias de tal forma que, si todos los test se han ejecutado correctamente, tengamos una
 documentación final completa y real. Además dicha documentación podrá ser incluida en la propia aplicación para que se
  encuentre accesible en el mismo contexto.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Así pues, la idea básica es:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;crear documentación &quot;plantilla&quot; donde explicamos nuestros recursos RESTful. Esta documentación es parte del proyecto
y se encontará versionada.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hacer referencia dentro de esta a &quot;snippets&quot; que serán generados automáticamente por nuestros test. Básicamente cada
uno de ellos generará un documento &quot;curl&quot;, un documento &quot;request&quot; y un documento &quot;response&quot;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;crear los test encargados de realizar las solicitudes REST y generar los snippets si el test se ejecuta correctamente.
Estos test pueden ser realizados mediante JUnit (siguiendo la documentación del proyecto) o mediante Spock (no documentado hasta la fecha)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;twitterpeople&quot;&gt;TwitterPeople&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Para explicar cómo integrar spring-rest-doc en nuestra aplicación Grails Rest, en este primer post vamos a crear una aplicación,
&lt;a href=&quot;https://github.com/pvidasoftware/twitterpeople&quot;&gt;TwitterPeople&lt;/a&gt;, la cual simplemente expone un recurso &lt;strong&gt;Person&lt;/strong&gt; contra el que realizar peticiones REST.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;TwitterPeople es un &quot;proxy&quot; de usuarios de Twitter de tal forma que al iniciar la aplicación la base de datos se encuentra
vacía y según se realizan peticiones REST al recurso &lt;strong&gt;Person&lt;/strong&gt; accede a Twitter para buscar el usuario solicitado y si existe
lo importa a su base de datos como un &lt;strong&gt;Person&lt;/strong&gt; y a partir de este punto se encuentra accesible como recurso REST.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;creamos_una_aplicación_rest_api&quot;&gt;creamos una aplicación rest-api&lt;/h3&gt;
&lt;div class=&quot;listingblock console&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;$grails create-app twitterpeople --profile rest-api

$cd twitterpeople

$grails compile

$grails idea&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;añadimos_dependencias_twitter4j&quot;&gt;añadimos dependencias Twitter4J&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;/build.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;dependencies{
    ...
    compile &quot;org.twitter4j:twitter4j-core:4.0.4&quot;
    ...
}
....
bootRun {
    jvmArgs = [
            &quot;-Dtwitter4j.oauth.consumerKey=${consumerKey}&quot;,
            &quot;-Dtwitter4j.oauth.consumerSecret=${consumerSecret}&quot;,
            &quot;-Dtwitter4j.oauth.accessToken=${accessToken}&quot;,
            &quot;-Dtwitter4j.oauth.accessTokenSecret=${secretToken}&quot;
    ]
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;/gradle.properties&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;consumerKey=lO****************Go*****
consumerSecret=tlhfC**********0U******************gbrW***********
accessToken=*********-***************************************c
secretToken=N***********************ai*0**********plufrC&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;grails-app/conf/spring/resources.groovy&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;    twitter(twitter4j.TwitterFactory) { bean -&amp;gt;
        bean.factoryMethod = &quot;getSingleton&quot;
        bean.singleton = true
    }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;creamos_artefactos_domain_service_interceptor&quot;&gt;creamos artefactos (domain, service, interceptor)&lt;/h3&gt;
&lt;div class=&quot;listingblock console&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;$grails create-domain-class Person&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;grails-app/domain/twitterpeople/Person.groovy&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;    @Resource(uri=&apos;/people&apos;, formats=[&apos;json&apos;], readOnly=true)
    class Person {

    // Person es un subconjunto de atributos de un User de Twitter
    ...

    }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock console&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;$grails create-service TwitterProxy&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;grails-app/services/twitterpeople/TwitterProxyService.groovy&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;     boolean createPerson( String id) {
     // si el id no existe buscaremos en twitter un usuario con ese nick
     // y lo incluiremos a la base de datos como un Person
     ...
     }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;grails-app/controllers/twitterpeople/PersonInterceptor.groovy&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;    TwitterProxyService twitterProxyService

        boolean before(){
            switch( params.action ){
                case &apos;show&apos;:
                    return twitterProxyService.createPerson(params.id)
            }

            true
        }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;testeando_nuestro_servicio&quot;&gt;Testeando nuestro servicio&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Por último crearíamos nuestro Rest Test utilizando RestBuilder como herramienta para invocar al servicio&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;src/integration-test/twitterpeople/SimpleSpec.groovy&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;...
        given:
        RestBuilder rest = new RestBuilder()

        when:
        RestResponse response = rest.get(&quot;http://localhost:8080/people&quot;)

        then:
        response.status == 200
...&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;probamos_la_aplicación_desde_consola&quot;&gt;probamos la aplicación desde consola&lt;/h3&gt;
&lt;div class=&quot;listingblock console&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;$gradle bootRun

curl http://localhost:8080/people
[]

curl http://localhost:8080/people/jagedn
{&quot;id&quot;:&quot;jagedn&quot;,&quot;description&quot;:&quot;no, si yo yaaa ....&quot;,&quot;followersCount&quot;:54,&quot;friendsCount&quot;:111,&quot;location&quot;:&quot;aqui&quot;}

curl http://localhost:8080/people
[{&quot;id&quot;:&quot;jagedn&quot;,&quot;description&quot;:&quot;no, si yo yaaa ....&quot;,&quot;followersCount&quot;:54,&quot;friendsCount&quot;:111,&quot;location&quot;:&quot;aqui&quot;}]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;documentación&quot;&gt;Documentación&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;En el siguiente post veremos cómo nuestro SimpleSpec puede ayudarnos para generar la documentación necesaria para
el servicio REST People.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	  </description>
    </item>
    
    <item>
      <title>Añadiendo Slides a JBake</title>
      <link>https://pvidasoftware.github.io/blog/blog/2016/add-jmpress-jbake.html</link>
      <pubDate>mar, 16 feb 2016 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">blog/2016/add-jmpress-jbake.html</guid>
      <description>
      &lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;slides_en_nuestro_blog&quot;&gt;slides en nuestro blog&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;JBake permite crear contenido estático más allá de post en el blog. Cuenta con un sistema de plantilla y una configuración
realmente simple para que podamos crear nuevos tipos de páginas en nuestro blog.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;En nuestro caso vamos a incluir un sistema de presentaciones basado
en &lt;a href=&quot;http://jmpressjs.github.io/docs/index.html&quot;&gt;JmPress&lt;/a&gt; (el cual a su vez se basa en
&lt;a href=&quot;http://impress.github.io/impress.js/&lt;mark&gt;/bored&lt;/mark&gt;&quot;&gt;ImpressJs&lt;/a&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Para ello vamos a:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;crear un nuevo espacio dentro del menú dedicado a nuestras presentaciones&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;añadir los javascript + css necesarios a nuestro asset&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;crear un nuevo template &lt;strong&gt;presentation.gsp&lt;/strong&gt; y añadirlo a la configuración de JBake&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;crear nuestra primera presentación&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;nueva_opción_del_menú&quot;&gt;Nueva opción del menú&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;templates/menu.gsp&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;            &amp;lt;li class=&quot;dropdown&quot;&amp;gt;
              &amp;lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&amp;gt;Slides &amp;lt;b class=&quot;caret&quot;&amp;gt;&amp;lt;/b&amp;gt;&amp;lt;/a&amp;gt;  &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;
              &amp;lt;ul class=&quot;dropdown-menu&quot;&amp;gt;
	&amp;lt;%presentations.each {ppt -&amp;gt;%&amp;gt;                                   &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;
		    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;&amp;lt;%if (content.rootpath) {%&amp;gt;${content.rootpath}&amp;lt;% } else { %&amp;gt;&amp;lt;% }%&amp;gt;${ppt.uri}&quot;&amp;gt;${ppt.title}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;
  	&amp;lt;%}%&amp;gt;
              &amp;lt;/ul&amp;gt;
            &amp;lt;/li&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Creamos un dropdown con bootstrap llamado Slides&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pediremos a JBake que nos de los contenidos de tipo &lt;strong&gt;presentationS&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Creamos un enlace al slide&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;añadir_contenido_a_asset&quot;&gt;Añadir contenido a asset&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Simplemente descargaremos los js+css necesarios y los ubicaremos en el directorio que corresponda. Así mismo modificaremos
la plantilla para que los incluya. Podriamos incluirlos de forma genérica o mejor aún únicamente cuando el contenido lo necesite:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;templates/header.gsp&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;&amp;lt;%if( content.type == &apos;presentation&apos;) {%&amp;gt;
    &amp;lt;link href=&quot;&amp;lt;%if (content.rootpath) {%&amp;gt;${content.rootpath}&amp;lt;% } else { %&amp;gt;&amp;lt;% }%&amp;gt;css/jmpressjs.simple.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&amp;gt;
&amp;lt;%}%&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;templates/footer.gsp&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;&amp;lt;%if( content.type == &apos;presentation&apos;) {%&amp;gt;
&amp;lt;script&amp;gt;
    \$(function() {                 &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;
        \$(&apos;#jmpress&apos;).jmpress();   &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;
    });
&amp;lt;/script&amp;gt;
&amp;lt;%}%&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Necesitamos &quot;escapar&quot; los simbolos de JQuery al estar dentro de un GSP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;jpmress&lt;/strong&gt; será como llamaremos a nuestro contenedor de slides&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;creando_un_nuevo_tipo_de_contenido&quot;&gt;Creando un nuevo tipo de contenido&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Primero indicaremos a JBake que existe un nuevo tipo de contenido &lt;strong&gt;presentation&lt;/strong&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;jbake.properties&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;template.presentation.file=presentation.gsp&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;y creamos una nueva plantilla para este tipo de contenido:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;presentation.gsp&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;&amp;lt;%include &quot;header.gsp&quot;%&amp;gt;

	&amp;lt;%include &quot;menu.gsp&quot;%&amp;gt;

    &amp;lt;div id=&quot;jmpress&quot;&amp;gt;   &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;
    ${content.body}
    &amp;lt;/div&amp;gt;

&amp;lt;%include &quot;footer.gsp&quot;%&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;jmpress indentifica a nuestro contenedor de slides&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;creando_nuestra_primera_slide&quot;&gt;Creando nuestra primera slide&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Ahora solo resta crear una presentación que queramos que aparezca en nuestro blog dentro de la sección &lt;strong&gt;Slides&lt;/strong&gt; por
lo que en crearemos:
- un directorio slides dentro de content para alojar nuestras presentaciones (el nombre puede ser lo que quieras)
- un nuevo documento HTML con la etiqueta type=presentation&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;slides/mi-primer-slide.html&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;title=Mi primera slide
date=2016-02-16
type=presentation
tags=blog, asciidoc, jpmpress, impressjs, jbake
status=published
~~~~~~

&amp;lt;div id=&quot;home&quot; class=&quot;step&quot;&amp;gt;
    &amp;lt;p&amp;gt;Hello! My name is jmpress.js...&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;step&quot; data-x=&quot;1000&quot;&amp;gt;
    &amp;lt;p&amp;gt;and this is a really simple demo.&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;step&quot; data-x=&quot;2000&quot;&amp;gt;
    &amp;lt;p&amp;gt;You might think it is boring...&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;step&quot; data-x=&quot;3000&quot;&amp;gt;
    &amp;lt;p&amp;gt;but that is the point. This is a simple example.&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;generando_y_publicando&quot;&gt;Generando y publicando&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Simplemente resta, como cada vez que añadimos contenido a JBake, generar el contenido y publicarlo.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	  </description>
    </item>
    
    <item>
      <title>Construye tu propia DSL</title>
      <link>https://pvidasoftware.github.io/blog/blog/2016/queryDSL-post.html</link>
      <pubDate>jue, 11 feb 2016 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">blog/2016/queryDSL-post.html</guid>
      <description>
      &lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;dsl_con_groovy&quot;&gt;DSL con Groovy&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;DSL, o &lt;a href=&quot;https://es.wikipedia.org/wiki/Lenguaje_espec%C3%ADfico_del_dominio&quot;&gt;Lenguaje específico de dominio&lt;/a&gt;, con Groovy
es realmente &quot;sencillo&quot; una vez que se entiende. Existen numerosos recursos, e incluso libros dedicados a ello exclusivamente,
por lo que no nos extenderemos demasiado en este post, simplemente apuntar que puedes diseñar tu propio DSL de tal forma
que la comunicación entre departamentos, por ejemplo, sea mucho más fluida y clara, o que tu código sea mucho más fácil de entender.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Para ello vamos a desarrollar un pequeño DSL que nos permitirá construir sentencias SQL (de toda la vida) de una forma
más manejable.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;querydsl&quot;&gt;QueryDSL&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;( Recuerda que puedes obtener el código de &lt;a href=&quot;https://github.com/pvidasoftware/QueryDSL&quot;&gt;https://github.com/pvidasoftware/QueryDSL&lt;/a&gt; )&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Mediante QueryDSL pretendemos obtener una String para poder lanzar consultas a nuestro motor de base de datos.
De forma tradicional haríamos algo parecido a:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;String query = &quot;select a.field1, a.field2 from mytable a inner join table2 b on a.field1 = b.field1 where a.field = 501 group by 1&quot;;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Como puedes imaginar, cuando la lista de campos crece, el número de joins aumenta o las condiciones varían la lógica para
construir la cadena se incrementa haciendola muchas veces imposible de seguir/entender.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Hoy en día exisen numerosos frameworks que ocultan esta complejidad y que incluso hacen el mapping de los datos a objetos, pero
hay también muchas veces donde no podemos/queremos disponer de estos frameworks.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Imaginemos el ejemplo anterior escrito de esta forma:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;def queryDSL = QueryDSL.build {
        select &apos;a.field1, a.field2&apos;  &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;
        from &apos;mytable a&apos;             &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;
        where{                       &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;
            and{
                eq &quot;a.field1&quot;, 501
            }
        }
        innerJoin &quot;table2 b&quot; on &quot;a.field1&quot; eq &quot;b.field1&quot;  &lt;b class=&quot;conum&quot;&gt;(4)&lt;/b&gt;
        groupBy 1   &lt;b class=&quot;conum&quot;&gt;(5)&lt;/b&gt;
    }
String select = queryDSL.SQL&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;campos que queremos&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;de qué tabla&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;condiciones de filtro&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;unión con otras tablas&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;agrupar por el primer campo&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Como vemos, las diferentes partes de la sentencia se encuentran separadas de tal forma que nos permite comentarios:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;def queryDSL = QueryDSL.build {
        // tomamos dos campos e ignoramos el resto
        select &apos;a.field1, a.field2&apos;
....&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;o incluso que el orden de la sintáxis no sea rígido :&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;def queryDSL = QueryDSL.build {
        select &apos;a.field1, a.field2&apos;
        from &apos;mytable a&apos;
        innerJoin &quot;table2 b&quot; on &quot;a.field1&quot; eq &quot;b.field1&quot;
        where{
....&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;construyendo_nuestra_querydsl&quot;&gt;Construyendo nuestra QueryDSL&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;La idea de QueryDSQL es que mediante una closure le iremos indicando las diferentes partes de una query para que al final
nos devuelva una cadena especialmente diseñada para ser ejecutada como sentencia SQL.
Así vemos que nuestra DSL tendría que tener una forma de especificar:
 - campo(s) a recuperar
 - tabla a la que consultar
 - posibilidad de enlazar con otras tablas (join)
 - sintáxis (opcinal) para poder filtrar (where) con posibilidad de parámetros con nombres
 - sintáxis (opcional) para poder agrupar&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Además vamos a querer que esta DSL nos permita obtener la query para hacer una select y/o un count sin tener que volver
 a escribir la closure.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;factoría_querydsl&quot;&gt;Factoría QueryDSL&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Lo primero que crearemos será un método estático que aceptará una &quot;closure&quot; como argumento (para saber más de closures
en groovy visita la documentación de &lt;a href=&quot;http://groovy-lang.org/closures.html:&quot;&gt;Groovy Lang&lt;/a&gt; ):&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;def static QueryDSL build( closure ) {
        QueryDSL dsl = new QueryDSL()
        closure.delegate = dsl
        closure()
        dsl
    }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Como puedes ver el método build crea una clase del tipo QueryDSL que al ser privada sólo puede ser creada por él, y se
lo asigna a la closure como delegate. De esta forma cuando se ejecute la closure los métodos que se llamen dentro de ella
que no tenga serán redirigidos al delegate para que los resuelva.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;populando_el_dsl&quot;&gt;&quot;Populando&quot; el dsl&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;La closure irá llamando a métodos en nuestro &lt;strong&gt;dsl&lt;/strong&gt; delegate pasandole argumentos.
De esta forma si la closure llama a un método &quot;select&quot; y el delegate lo implementa, este será llamado automáticamente.
Además gracias a Groovy elegirá el método más adecuado:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;   def select(String field){
        this.fields = field
    }

    def select(String[]fields){
        this.fields = fields.join(&apos;,&apos;)
    }

    def select(List fields){
        this.fields = fields.join(&apos;,&apos;)
    }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;usando_el_dsl&quot;&gt;Usando el dsl&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Una vez que tenemos un queryDSL &quot;populado&quot; podremos solicitarle que nos devuelva por ejemplo la sentencia SQL para ser
usada en un data source o la sentencia SQL para contar el número de registros que cumplen la condición:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;new Sql(dataSource).rows(queryDSL.SQL)
new Sql(dataSource).rows(queryDSL.CountSQL)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;construyendo_la_sentencia&quot;&gt;Construyendo la sentencia&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Cuando le pedimos la cadena SQL a nuestro dsl, este simplemente irá construyendo la sentencia con los datos que ha ido
guardando durante la ejecución de la closure:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt; public String getSQL( ){
        StringWriter writer = new StringWriter()
        writer.write(&quot;SELECT $fields&quot;)
        writer.write(&quot;\nFROM \n$fromTables&quot;)
        if( whereStr &amp;amp;&amp;amp; whereStr.length())
            writer.write(&quot;\n$whereStr&quot;)
        if( groupStr &amp;amp;&amp;amp; groupStr.length())
            writer.write(&quot;\nGROUP BY $groupStr&quot;)
        if( trace ){
            println( writer.toString() )
        }
        writer.toString()
    }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Este DSL es muy básico y no realiza todas las comprobaciones que se deberían pero la idea se entiende. Simplemente va
uniendo las diferentes partes que ha ido guardando. De esta forma el mismo objeto nos puede devolver un SELECT que un
COUNT&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;rizando_el_rizo&quot;&gt;Rizando el rizo&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Hasta aquí el DSL no tiene mucha complicación y aunque ya nos puede servir para hacer cosas sencillas en muchos casos
nuestro lenguaje de negocio nos pedirá que seamos un poco más &quot;rico&quot; en la composición.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Un buen ejemplo en QueryDSL es la parte en la que queremos indicar la unión con otra table e indicar los campos por
 los que queremos realizar esta union:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;def queryDSL = QueryDSL.build {
....
        innerJoin &quot;table2 b&quot; on &quot;a.field1&quot; eq &quot;b.field1&quot;
....
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Nuestro lenguaje va a permitirnos indicar la tabla mediante &lt;strong&gt;innerJoin&lt;/strong&gt; y además para este caso nos va a permitir especificar
por qué campos hacerlo mediante &lt;strong&gt;on&lt;/strong&gt; y cómo realizar esta unión mediante alguno de los operadores &lt;strong&gt;eq,ne,le,gt,&amp;#8230;&amp;#8203;&lt;/strong&gt;
 He buscado que esta sintáxis sea similar a la típica de una sentencia SQL para facilitar su uso, pero con un poco de imaginación
 podríamos haber diseñado otro DSL que nos resulte más explicativo, como por ejemplo:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;def queryDSL = QueryDSL.build {
....
        // una innerJoin un poco más verbose:
        la unes con &quot;table2&quot; por el campo &quot;field1&quot; cuando son iguales
....
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Para poder hacer que nuestra DSL acepte la sintáxis expuesta usaremos una técnica de Groovy donde el método &lt;strong&gt;innerJoin&lt;/strong&gt;
devuelve un mapa de closures admitidas (en nuestro caso &lt;strong&gt;on&lt;/strong&gt; únicamente). Esta técnica se puede usar recursivamente de
tal forma que una closure nos devuelva un nuevo mapa con la sintáxis que admite después de ella:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;def innerJoin( String table  ){
        join(&quot;inner&quot;,table)
}

def join( String op, String table2){
        QueryDSL dsl = this
        [
                on:{ f1 -&amp;gt;
                    [
                     eq:{f2-&amp;gt;
                        dsl.addJoin(op,table2,f1,&apos;=&apos;,f2)
                         dsl
                     },
                     ge:{f2-&amp;gt;
                         dsl.addJoin(op,table2,f1,&apos;&amp;gt;=&apos;,f2)
                         dsl
                     },
                     le:{f2-&amp;gt;
                         dsl.addJoin(op,table2,f1,&apos;=&amp;lt;&apos;,f2)
                         dsl
                     },
                     gt:{f2-&amp;gt;
                         dsl.addJoin(op,table2,f1,&apos;&amp;gt;&apos;,f2)
                         dsl
                     },
                     lt:{f2-&amp;gt;
                         dsl.addJoin(op,table2,f1,&apos;&amp;lt;&apos;,f2)
                         dsl
                     },
                     distinct:{f2-&amp;gt;
                         dsl.addJoin(op,table2,f1,&apos;&amp;lt;&amp;gt;&apos;,f2)
                         dsl
                     },
                    ]
                }
        ]
    }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Como podemos ver &lt;strong&gt;innerJoin&lt;/strong&gt; simplemente delega en el método &lt;strong&gt;join&lt;/strong&gt; indicándole el tipo join que queremos hacer (inner, left, right&amp;#8230;&amp;#8203;)
 y pasándole el argumento que ha recibido (String table).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Lo primero que hará &lt;strong&gt;join&lt;/strong&gt; será guardarse una referencia a sí mismo para poder continuar con la closure principal una vez
interpretada en la que estamos y después devolverá un Map de closures donde la clave permitirá a Groovy saber cúal ejecutar, &lt;strong&gt;on&lt;/strong&gt;
en nuestro caso.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;on&lt;/strong&gt; aceptará como argumentos el nombre de un campo (f1) y a su vez devolverá un nuevo mapa de las posibles closures que
admite ( eq, ge, le, .. ). En este caso cada una de ellas espera una cadena que indica el segundo campo (f2) y como todas
son muy parecidas simplemente llamamos a una función común &lt;strong&gt;addJoin&lt;/strong&gt; donde unimos todos los argumentos que hemos ido recolectando.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Por último las closures finales de &lt;strong&gt;innerJoin&lt;/strong&gt; devolverán la referencia que guardamos al inicio para que se siga con nuestro DSL.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;bien_y_para_qué_una_dsl&quot;&gt;Bien, &amp;#8230;&amp;#8203; y para qué una DSL ?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Crear tus propias DSLs te puede permitir facilitar la interacción con la parte de negocio (la gente de ventas, contabilidad, &amp;#8230;&amp;#8203;).
Por ejemplo, supongamos que has diseñado un sistema de seguimiento de entregas para el departamento de atención al cliente donde existe
un compromiso de entrega en función del dia de la semana, del año, si es fiesta, etc.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Podríamos diseñar un DSL que el departamento de atencion al cliente podría proporcionarnos cada mes parecido a:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;pedido Lunes, Miercoles, Viernes     entrega  2 días despues
pedido Martes                        entrega  Miercoles
pedido 6 de Enero                    entrega  9 enero&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;la imaginación es el límite.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	  </description>
    </item>
    
    <item>
      <title>Creando un blog estático con JBake</title>
      <link>https://pvidasoftware.github.io/blog/blog/2016/first-post.html</link>
      <pubDate>jue, 4 feb 2016 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">blog/2016/first-post.html</guid>
      <description>
      &lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;adios_wordpress&quot;&gt;Adios WordPress&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Qué duda cabe que WordPress sigue siendo uno de los reyes para la generación de blogs. Sin embargo plantea algunos
problemas:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;necesitas alojamiento PHP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;necesitas una base de datos (MySQL)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a pesar de que el proceso de instalación es sencillo, no está al alcance de todos.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Nuestro primer blog estaba basado en WP, pero PHP no es nuestro lenguaje preferido y aunque nuestro alojamiento nos
permite utilizar bases de datos y php, creíamos que debíamos aplicar las herramientas y lenguajes que usamos a diario.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Y un buen día leyendo el blog de &lt;a href=&quot;http://melix.github.io/blog/2014/02/hosting-jbake-github.html&quot;&gt;Cedric Champeau&lt;/a&gt;
&amp;#8230;&amp;#8203; descubrimos &lt;a href=&quot;http://www.jbake.org&quot; class=&quot;bare&quot;&gt;http://www.jbake.org&lt;/a&gt;, un generador de blog estático en Groovy y
nos pusimos manos a la obra. Tras buscar un poco más de información y utilidades, este es el entorno que usaremos:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://sdkman.io/&quot;&gt;SdkMan&lt;/a&gt; como gestor de frameworks.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://groovy-lang.org&quot;&gt;Groovy&lt;/a&gt; como lenguaje de referencia.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cjstehno/lazybones-templates&quot;&gt;Chris&apos; Lazybones Templates&lt;/a&gt; magnifica plantilla que nos permitirá
empezar inmediatamente con JBake.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;Intellij&lt;/a&gt; como entorno desde el que realizar la edición, revisión y publicación.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Como bola extra, la plantilla que nos proporciona Chris nos incluye un entorno y herramientas muy útiles para los &quot;groovyeros&quot;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;un proyecto Gradle&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;plugin jBake para Gradle&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;plugin ajoberstar.github-pages para publicar en GitHub nuestro blog&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;customizando_nuestro_blog&quot;&gt;Customizando nuestro blog&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Una vez tengamos montada la estructura básica y hayamos podido generar nuestro primer blog, podremos empezar
 a ajustarle a nuestro gusto. Por defecto JBake usa Bootstrap pero podrías usar cualquier otra utilidad o incluso
 usar la tuya propia. En un próximo post explicaré cómo darle un diseño a tu blog JBake más &quot;&lt;a href=&quot;https://www.google.com/design/spec/material-design/introduction.html&quot;&gt;material&lt;/a&gt;&quot;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Lo primero que cambiaremos será el titulo y para ello crearemos una variable de proyecto en el fichero
de propiedades de jbake:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;jbake.properties&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;site.title=@pvidasoftware&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Ahora podremos usar esa nueva variable en cualquier parte de nuestras páginas:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;templates/header.gsp&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;&amp;lt;title&amp;gt;&amp;lt;%if (content.title) {%&amp;gt;${content.title}&amp;lt;% } else { %&amp;gt;${config.site_title}&amp;lt;% }%&amp;gt;&amp;lt;/title&amp;gt; &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;La configuracion site.title se referencia en el template como config.site_title&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	  </description>
    </item>
    

  </channel> 
</rss>
